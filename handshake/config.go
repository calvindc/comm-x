package handshake

// NetworkString define the network id of this protocol, can be used with newwrap to wap the  underlying connection.
const NetworkString = "shs-dpc"

// ChallengeLength is the length of a challenge message in bytes
const ChallengeLength = 64

// ClientAuthLength is the length of a clientAuth message in bytes
const ClientAuthLength = 16 + 32 + 64

// ServerAuthLength is the length of a serverAuth message in bytes
const ServerAuthLength = 16 + 64

// MACLength is the length of a MAC in bytes
const MACLength = 16

// ed25519Blacklist is a list of elements of the ed25519 curve that have low order.
// from github.com/jedisct1/libsodium
var ed25519Blacklist = [7][32]byte{
	/* 0 (order 4) */
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	/* 1 (order 1) */
	{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	/* 2707385501144840649318225287225658788936804267575313519463743609750303402022
	   (order 8) */
	{0x26, 0xe8, 0x95, 0x8f, 0xc2, 0xb2, 0x27, 0xb0, 0x45, 0xc3, 0xf4,
		0x89, 0xf2, 0xef, 0x98, 0xf0, 0xd5, 0xdf, 0xac, 0x05, 0xd3, 0xc6,
		0x33, 0x39, 0xb1, 0x38, 0x02, 0x88, 0x6d, 0x53, 0xfc, 0x05},
	/* 55188659117513257062467267217118295137698188065244968500265048394206261417927
	   (order 8) */
	{0xc7, 0x17, 0x6a, 0x70, 0x3d, 0x4d, 0xd8, 0x4f, 0xba, 0x3c, 0x0b,
		0x76, 0x0d, 0x10, 0x67, 0x0f, 0x2a, 0x20, 0x53, 0xfa, 0x2c, 0x39,
		0xcc, 0xc6, 0x4e, 0xc7, 0xfd, 0x77, 0x92, 0xac, 0x03, 0x7a},
	/* p-1 (order 2) */
	{0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f},
	/* p (=0, order 4) */
	{0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f},
	/* p+1 (=1, order 1) */
	{0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f},
}

// hasSmallOrder checks if the passed group element is of low order.
/*
 Input:
 a[0]+256*a[1]+...+256^31*a[31] = a
 b[0]+256*b[1]+...+256^31*b[31] = b

 Output:
 s[0]+256*s[1]+...+256^31*s[31] = (ab) mod l
 where l = 2^252 + 27742317777372353535851937790883648493.
*/
func hasSmallOrder(groupElement []byte) bool {
	/*
			unsigned char c[7] = { 0 };
		    unsigned int  k;
		    size_t        i, j;

		    COMPILER_ASSERT(7 == sizeof blacklist / sizeof blacklist[0]);
		    for (j = 0; j < 31; j++) {
		        for (i = 0; i < sizeof blacklist / sizeof blacklist[0]; i++) {
		            c[i] |= s[j] ^ blacklist[i][j];
		        }
		    }
		    for (i = 0; i < sizeof blacklist / sizeof blacklist[0]; i++) {
		        c[i] |= (s[j] & 0x7f) ^ blacklist[i][j];
		    }
		    k = 0;
		    for (i = 0; i < sizeof blacklist / sizeof blacklist[0]; i++) {
		        k |= (c[i] - 1);
		    }
		    return (int) ((k >> 8) & 1);
	*/
	var c [7]byte
	var k, i, j int
	for j = 0; j < 31; j++ {
		for i = 0; i < len(ed25519Blacklist); i++ {
			c[i] |= groupElement[j] ^ ed25519Blacklist[i][j]
		}
	}
	k = 0
	for i = 0; i < len(ed25519Blacklist); i++ {
		k |= int(c[i]) - 1
	}
	return ((k >> 8) & 1) == 1
}
